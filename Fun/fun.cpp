#include <h3mtxt/H3MWriter/writeh3m.h>
#include <h3mtxt/Map/Map.h>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <random>
#include <stdexcept>

namespace fs = std::filesystem;

namespace
{
  h3m::PlayerSpecs generateTestPlayerSpecs()
  {
    return h3m::PlayerSpecs{
      .can_be_human = false,
      .can_be_computer = false,
      .behavior = h3m::PlayerBehavior::Random,
      .customized_alignments = false,
      .allowed_alignments {},
      .random_town = false,
      .main_town {},
      .starting_hero {
        .is_random = false,
        .type = static_cast<h3m::HeroType>(0xFF),
        .portrait = h3m::HeroPortrait::DEFAULT
      },
      .additional_info {}
    };
  }

  h3m::Map generateTestMap(std::uint32_t map_size = 36)
  {
    h3m::Map map {
      .format = h3m::MapFormat::ShadowOfDeath,
      .basic_info {
        .is_playable = false,
        .map_size = map_size,
        .has_two_levels = false,
        .name = "Test map",
        .description = "Test map generated by h3mparser.",
        .difficulty = h3m::MapDifficulty::Easy,
        .max_hero_level = 0
      },
      .players {
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs()
      },
      .additional_info {
        // Normal victory condition.
        .victory_condition {},
        // Normal loss condition.
        .loss_condition {},
        // No teams.
        .teams {},
        // Enable all heroes.
        .heroes_availability = h3m::HeroesAvailability::makeAllAvailability(),
        // No placeholder heroes.
        .placeholder_heroes {},
        // No custom heroes.
        .custom_heroes {},
        .reserved {},
        .artifacts_nonavailability {},
        .disabled_spells {},
        .disabled_skills {},
        .rumors {
          h3m::Rumor {
            .name = "Rumor",
            .description = "This is the only rumor."
          }
        },
        // No heroes with customized settings.
        .heroes_settings {}
      },
      .tiles = std::vector<h3m::Tile>(map_size * map_size, h3m::Tile{
        .terrain_type = h3m::TerrainType::Rock,
        .terrain_sprite = 0
      }),
      .global_events {
        h3m::GlobalEvent {
          h3m::TimedEventBase {
            .name = "Global event",
            .message = "Enjoy some resources.",
            .resources {
              .data {10, 5, 10, 5, 5, 5, 1000}
             },
            .affected_players {
              .bitset = 0xFF
            },
            .applies_to_human = true,
            .applies_to_computer = true,
            .day_of_first_occurence = 0,
            .repeat_after_days = 0
          }
        }
      }
    };
    return map;
  }

  void fillWithWaterTiles(h3m::Map& map)
  {
    std::random_device rd;
    std::mt19937 gen(rd());
    // Sprites [21; 32] look like non-coastal Water tiles.
    std::uniform_int_distribution<> distrib(21, 32);

    // Set random water tiles.
    for (h3m::Tile& tile : map.tiles)
    {
      tile.terrain_type = h3m::TerrainType::Water;
      tile.terrain_sprite = distrib(gen);
      // Note: we can apply random mirroring as well. The official Map Editor doesn't
      // apply mirroring to non-coastal Water tiles (and switches it off if you modify a
      // water region with mirrored non-coastal tiles).
      tile.mirroring = 0;
    }
  }

  constexpr bool isEligibleLavaTile(const h3m::Tile& tile) noexcept
  {
    // Lava sprites [49; 72] are "pure", i.e. they don't border other terrain types.
    return tile.terrain_type == h3m::TerrainType::Lava &&
           tile.terrain_sprite >= 49 &&
           tile.terrain_sprite <= 72;
  }

  // Replaces the sprites of "pure" Lava tiles with random animated Lava sprites.
  void makeUltimateLava(h3m::Map& map)
  {
    std::random_device rd;
    std::mt19937 gen(rd());
    // Sprites [65; 70] look like animated Lava tiles.
    std::uniform_int_distribution<> distrib_sprite(65, 70);
    std::uniform_int_distribution<> distrib_mirror(0, 3);
    for (h3m::Tile& tile : map.tiles)
    {
      if (isEligibleLavaTile(tile))
      {
        tile.terrain_sprite = distrib_sprite(gen);
        tile.mirroring = distrib_mirror(gen);
      }
    }
  }

  // Access the specified tile.
  // \param map - input map.
  // \param x - X coordinate of the tile.
  // \param y - Y coordinate of the tile.
  // \return the tile (x, y) or nullptr if x >= map_size or y >= map_size.
  h3m::Tile* safeGetTile(h3m::Map& map, std::uint32_t x, std::uint32_t y)
  {
    const std::uint32_t map_size = map.basic_info.map_size;
    if (x >= map_size || y >= map_size)
    {
      return nullptr;
    }
    return &map.tiles[static_cast<std::size_t>(y) * map_size + x];
  }

  // Draws a "fake" island at the specified location.
  //
  // A "fake" island is a 4x4 region with specific Water tiles, which
  // look like a diamond-shaped spot of land, but actually it's all water.
  // \param map - map to modify.
  // \param x - X coordinate of the top left corner of the region.
  // \param y - Y coordinate of the top left corner of the region.
  void drawFakeIsland(h3m::Map& map, std::uint32_t x, std::uint32_t y)
  {
    if (h3m::Tile* tile = safeGetTile(map, x, y + 1))
    {
      tile->terrain_sprite = 19;
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x, y + 2))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y))
    {
      tile->terrain_sprite = 19;
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 1))
    {
      tile->terrain_sprite = 17; // 16 also works
      tile->mirroring = 3;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 2))
    {
      tile->terrain_sprite = 17;
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 3))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y + 1))
    {
      tile->terrain_sprite = 17;
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y + 2))
    {
      tile->terrain_sprite = 17;
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y + 3))
    {
      tile->terrain_sprite = 15;
      tile->mirroring = 3;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 3, y + 1))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 3, y + 2))
    {
      tile->terrain_sprite = 15;
      tile->mirroring = 3;
    }
  }

  // Draws a "fake" mini-island at the specified location.
  //
  // A "fake" mini-island is a 2x2 region with specific Water tiles, which
  // look as if there's a small spot of land in the center, but actually it's all water.
  // \param map - map to modify.
  // \param x - X coordinate of the top left corner of the mini-island.
  // \param y - Y coordinate of the top left corner of the mini-island.
  void drawFakeMiniIsland(h3m::Map& map, std::uint32_t x, std::uint32_t y)
  {
    // Sprites [12; 15] v [18; 19] look like coast in the SouthEastern corner of the tile.
    constexpr std::uint8_t kSprites[] = { 12, 13, 14, 15, 18, 19 };
    constexpr std::size_t kNumSprites = std::size(kSprites);
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distrib(0, kNumSprites - 1);
    const auto generate_random_sprite = [&]() {
      return kSprites[distrib(gen)];
      };

    if (h3m::Tile* tile = safeGetTile(map, x, y))
    {
      tile->terrain_sprite = generate_random_sprite();
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y))
    {
      tile->terrain_sprite = generate_random_sprite();
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x, y + 1))
    {
      tile->terrain_sprite = generate_random_sprite();
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 1))
    {
      tile->terrain_sprite = generate_random_sprite();
      tile->mirroring = 3;
    }
  }

  // Draws a "fake" vertical strip of land at the specified location.
  //
  // A "fake" vertical strip of land is a 2xN region with specific Water tiles, which
  // look as if it's thin strip of land, but actually it's all water.
  // \param map - map to modify.
  // \param x - X coordinate of the top left corner of the strip.
  // \param y - Y coordinate of the top left corner of the strip.
  // \param length - the length of the strip in H3M tiles.
  void drawFakeVerticalLandStrip(h3m::Map& map, std::uint32_t x, std::uint32_t y, std::uint32_t length)
  {
    // Sprites [4; 7] look like coast to the West of the tile.
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<> distrib(4, 7);
    const auto generate_random_sprite = [&]() {
      return distrib(gen);
      };

    for (std::uint32_t i = 0; i < length; ++i)
    {
      if (h3m::Tile* tile = safeGetTile(map, x, y + i))
      {
        tile->terrain_sprite = generate_random_sprite();
        tile->mirroring = 1;
      }
      if (h3m::Tile* tile = safeGetTile(map, x + 1, y + i))
      {
        tile->terrain_sprite = generate_random_sprite();
        tile->mirroring = 0;
      }
    }
  }

  // (N+4)xN region which looks like a diagonal strip of land from NW to SE, but actually it's all water.
  void drawFakeDiagonalLandStripSE(h3m::Map& map, std::uint32_t x, std::uint32_t y, std::uint32_t length)
  {
    std::random_device rd;
    std::mt19937 gen(rd());
    // Sprites [12; 15] v [18; 19] look like coast in the SouthEastern corner of the tile.
    constexpr std::uint8_t kCornerCoastSprites[] = { 12, 13, 14, 15, 18, 19 };
    std::uniform_int_distribution<> corner_coast_distrib(0, std::size(kCornerCoastSprites) - 1);
    const auto generate_corner_coast_sprite = [&]() {
      return kCornerCoastSprites[corner_coast_distrib(gen)];
      };
    // Sprites [16; 17] look like diagonal coast NorthWest of the tile.
    std::uniform_int_distribution<> diagonal_coast_distrib(16, 17);
    const auto generate_diagonal_coast_sprite = [&]() {
      return diagonal_coast_distrib(gen);
      };

    for (std::uint32_t i = 0; i < length; ++i)
    {
      if (h3m::Tile* tile = safeGetTile(map, x + i, y + i))
      {
        tile->terrain_sprite = generate_corner_coast_sprite();
        tile->mirroring = 2;
      }
      if (h3m::Tile* tile = safeGetTile(map, x + i + 1, y + i))
      {
        tile->terrain_sprite = generate_diagonal_coast_sprite();
        tile->mirroring = 1;
      }
      if (h3m::Tile* tile = safeGetTile(map, x + i + 2, y + i))
      {
        tile->terrain_sprite = generate_diagonal_coast_sprite();
        tile->mirroring = 2;
      }
      if (h3m::Tile* tile = safeGetTile(map, x + i + 3, y + i))
      {
        tile->terrain_sprite = generate_corner_coast_sprite();
        tile->mirroring = 1;
      }
    }
  }

  void drawFakeIslands(h3m::Map& map)
  {
    drawFakeIsland(map, 9, 9);
    drawFakeMiniIsland(map, 20, 8);
    drawFakeMiniIsland(map, 20, 10);
    drawFakeMiniIsland(map, 22, 9);
    drawFakeMiniIsland(map, 24, 11);
    drawFakeMiniIsland(map, 22, 12);
    drawFakeMiniIsland(map, 25, 9);
    drawFakeMiniIsland(map, 26, 13);
    drawFakeVerticalLandStrip(map, 10, 15, 10);
    drawFakeVerticalLandStrip(map, 12, 15, 10);
    drawFakeVerticalLandStrip(map, 14, 15, 10);
    drawFakeDiagonalLandStripSE(map, 20, 20, 10);
    drawFakeDiagonalLandStripSE(map, 24, 20, 10);
  }

  h3m::Map generateMapWithAllTerrainSprites()
  {
    constexpr std::uint8_t kNumTerrainTypes = 10;

    h3m::Map map = generateTestMap(108);
    map.basic_info.name = "All terrain sprites";
    map.basic_info.description = "This map is a cheatsheet for viewing terrain sprites in H3M.\n"
                                 "Each tile (X, Y) has the terrain type X and the terrain sprite Y.\n"
                                 "If X is not a valid terrain type or Y is not a valid sprite for X, "
                                 "the tile has a campfire object on that tile.";
    for (h3m::Tile& tile : map.tiles)
    {
      tile.terrain_type = h3m::TerrainType::Rock;
      tile.terrain_sprite = 0;
    }
    for (std::uint8_t terrain_type_idx = 0; terrain_type_idx < kNumTerrainTypes; ++terrain_type_idx)
    {
      const h3m::TerrainType terrain_type = static_cast<h3m::TerrainType>(terrain_type_idx);
      const std::uint8_t num_sprites = h3m::countSprites(terrain_type);
      for (std::uint8_t sprite = 0; sprite < num_sprites; ++sprite)
      {
        if (h3m::Tile* tile = safeGetTile(map, sprite, terrain_type_idx))
        {
          tile->terrain_type = terrain_type;
          tile->terrain_sprite = sprite;
        }
      }
    }
    map.objects_attributes.push_back(h3m::ObjectAttributes{
      .def = "adcfra.def",
      .object_class = h3m::ObjectClass::CAMPFIRE,
      .object_number = 0,
      .object_group = h3m::ObjectGroup::Treasure,
      });
    for (std::uint32_t y = 0; y < map.basic_info.map_size; ++y)
    {
      const std::uint8_t num_sprites =
        (y >= kNumTerrainTypes) ? 0 : h3m::countSprites(static_cast<h3m::TerrainType>(y));
      for (std::uint32_t x = num_sprites; x < map.basic_info.map_size; ++x)
      {
        map.objects_details.push_back(h3m::ObjectDetails{
          .x = static_cast<std::uint8_t>(x),
          .y = static_cast<std::uint8_t>(y),
          .z = 0,
          .kind = 0
          });
      }
    }
    return map;
  }

  h3m::Map generateMapWithHeroFace(h3m::HeroPortrait portrait)
  {
    h3m::Map map = generateTestMap(36);
    map.basic_info.name = "Test spell scroll";
    map.basic_info.description = "Testing if a spell scroll can be added as an artifact.";
    for (h3m::Tile& tile : map.tiles)
    {
      tile.terrain_type = h3m::TerrainType::Grass;
      tile.terrain_sprite = 49;
    }
    map.objects_attributes.push_back(h3m::ObjectAttributes{
      .def = "ah00_e.def",
      .passability {255, 255, 255, 255, 255, 191},
      .actionability {0, 0, 0, 0, 0, 64},
      .object_class = h3m::ObjectClass::HERO,
      .object_number = 0,
      .object_group = h3m::ObjectGroup::Hero,
      .is_ground = 0
      });
    map.objects_details.push_back(h3m::ObjectDetails{
      .x = 1,
      .y = 0,
      .z = 0,
      .kind = 0,
      .details = h3m::ObjectDetailsData<h3m::MetaObjectType::HERO> {
        .absod_id = 69,
        .owner = 0,
        .type = h3m::HeroType::H3M_HERO_ORRIN,
        .portrait = portrait,
        .secondary_skills = std::vector<h3m::SecondarySkill> {
          h3m::SecondarySkill {.type = h3m::SecondarySkillType::Estates, .level = 0xFF},
        },
        .artifacts = h3m::HeroArtifacts {
          .backpack {
            h3m::ArtifactType::IRONFIST_OF_THE_OGRE
            //static_cast<h3m::ArtifactType>(144)
          }
        },
        .patrol_radius = 255
      }
    });
    return map;
  }
}

int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cout << "Usage: Fun map-path" << std::endl;
    return -1;
  }

  try
  {
    const fs::path path_map(argv[1]);
    std::ofstream out_stream(path_map, std::ios_base::out | std::ios_base::binary);
    const h3m::Map map = generateMapWithHeroFace(h3m::HeroPortrait::ADELA);
    //h3m::Map map = generateTestMap();
    //fillWithWaterTiles(map);
    //drawFakeIslands(map);
    h3m::writeh3m(out_stream, map);
  }
  catch (const std::exception& error)
  {
    std::cerr << error.what() << std::endl;
  }
  catch (...)
  {
    std::cerr << "Unknown error." << std::endl;
  }

  return 0;
}
