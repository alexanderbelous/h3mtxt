#include <h3mparser/parseh3m.h>
#include <h3mparser/writeText.h>
#include <h3mparser/writeh3m.h>

#include <filesystem>
#include <fstream>
#include <iostream>
#include <random>
#include <stdexcept>

namespace fs = std::filesystem;

namespace
{
  h3m::PlayerSpecs generateTestPlayerSpecs()
  {
    return h3m::PlayerSpecs{
      .can_be_human = false,
      .can_be_computer = false,
      .behavior = h3m::PlayerBehavior::Random,
      .customized_alignments = false,
      .allowed_alignments {},
      .random_town = false,
      .main_town {},
      .starting_hero {
        .is_random = false,
        .type = static_cast<h3m::HeroType>(0xFF),
        .face = 0
      },
      .additional_info {}
    };
  }

  h3m::Map generateTestMap()
  {
    constexpr std::uint32_t kMapSize = 36;

    h3m::Map map {
      .format = h3m::MapFormat::ShadowOfDeath,
      .basic_info {
        .is_playable = false,
        .map_size = kMapSize,
        .has_two_levels = false,
        .name = "Test map",
        .description = "Test map generated by h3mparser.",
        .difficulty = h3m::MapDifficulty::Easy,
        .max_hero_level = 0
      },
      .players {
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs(),
        generateTestPlayerSpecs()
      },
      .additional_info {
        // Normal victory condition.
        .victory_condition {},
        // Normal loss condition.
        .loss_condition {},
        // No teams.
        .teams {},
        // Disable all heroes.
        .heroes_availability {},
        // No placeholder heroes.
        .placeholder_heroes {},
        // No custom heroes.
        .custom_heroes {},
        .reserved {},
        .artifacts_nonavailability {},
        .spells_nonavailability {},
        .skills_nonavailability {},
        .rumors {
          h3m::Rumor {
            .name = "Rumor",
            .description = "This is the only rumor."
          }
        },
        // No heroes with customized settings.
        .heroes_settings {}
      },
      .tiles = std::vector<h3m::Tile>(kMapSize * kMapSize),
      .global_events {
        h3m::GlobalEvent {
          .name = "Global event",
          .message = "Enjoy some resources.",
          .resources {10, 5, 10, 5, 5, 5, 1000},
          .affected_players = h3m::BitSet<1>(std::array<std::uint8_t, 1> {0xFF}),
          .applies_to_human = true,
          .applies_to_computer = true,
          .day_of_first_occurence = 0,
          .repeat_after_days = 0
        }
      }
    };
    return map;
  }

  void fillWithWaterTiles(h3m::Map& map)
  {
    constexpr std::uint8_t kWaterSpriteMin = 21;
    constexpr std::uint8_t kWaterSpriteMax = 32;
    constexpr std::uint8_t kNumWaterSprites = kWaterSpriteMax - kWaterSpriteMin + 1;
    std::mt19937 gen;
    std::uniform_int_distribution<> distrib(kWaterSpriteMin, kWaterSpriteMax);

    // Set random water tiles.
    for (h3m::Tile& tile : map.tiles)
    {
      tile.terrain_type = h3m::TerrainType::Water;
      // These are non-coastal water tiles. Maybe there are more, idk.
      // 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32
      tile.terrain_sprite = distrib(gen);
      tile.mirroring = 0;
    }
  }

  // Access the specified tile.
  // \param map - input map.
  // \param x - X coordinate of the tile.
  // \param y - Y coordinate of the tile.
  // \return the tile (x, y) or nullptr if x >= map_size or y >= map_size.
  h3m::Tile* safeGetTile(h3m::Map& map, std::uint32_t x, std::uint32_t y)
  {
    const std::uint32_t map_size = map.basic_info.map_size;
    if (x >= map_size || y >= map_size)
    {
      return nullptr;
    }
    return &map.tiles[y * map_size + x];
  }

  // Draws a "fake" island at the specified location.
  //
  // A "fake" island is a 4x4 region with specific Water tiles, which
  // look like a diamond-shaped spot of land, but actually it's all water.
  // \param map - map to modify.
  // \param x - X coordinate of the top left corner of the region.
  // \param y - Y coordinate of the top left corner of the region.
  void drawFakeIsland(h3m::Map& map, std::uint32_t x, std::uint32_t y)
  {
    if (h3m::Tile* tile = safeGetTile(map, x, y + 1))
    {
      tile->terrain_sprite = 19;
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x, y + 2))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y))
    {
      tile->terrain_sprite = 19;
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 1))
    {
      tile->terrain_sprite = 17; // 16 also works
      tile->mirroring = 3;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 2))
    {
      tile->terrain_sprite = 17;
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 3))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y + 1))
    {
      tile->terrain_sprite = 17;
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y + 2))
    {
      tile->terrain_sprite = 17;
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 2, y + 3))
    {
      tile->terrain_sprite = 15;
      tile->mirroring = 3;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 3, y + 1))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 3, y + 2))
    {
      tile->terrain_sprite = 15;
      tile->mirroring = 3;
    }
  }

  // Draws a "fake" mini-island at the specified location.
  //
  // A "fake" mini-island is a 2x2 region with specific Water tiles, which
  // look as if there's a small spot of land in the center, but actually it's all water.
  // \param map - map to modify.
  // \param x - X coordinate of the top left corner of the mini-island.
  // \param y - Y coordinate of the top left corner of the mini-island.
  void drawFakeMiniIsland(h3m::Map& map, std::uint32_t x, std::uint32_t y)
  {
    if (h3m::Tile* tile = safeGetTile(map, x, y))
    {
      tile->terrain_sprite = 19;
      tile->mirroring = 0;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 1;
    }
    if (h3m::Tile* tile = safeGetTile(map, x, y + 1))
    {
      tile->terrain_sprite = 13;
      tile->mirroring = 2;
    }
    if (h3m::Tile* tile = safeGetTile(map, x + 1, y + 1))
    {
      tile->terrain_sprite = 15;
      tile->mirroring = 3;
    }
  }

  void drawFakeIslands(h3m::Map& map)
  {
    const std::uint32_t kMapSize = map.basic_info.map_size;

    drawFakeIsland(map, 9, 9);
    drawFakeMiniIsland(map, 20, 10);
    drawFakeMiniIsland(map, 22, 9);
    drawFakeMiniIsland(map, 24, 11);
    drawFakeMiniIsland(map, 22, 12);

    // Fake thin line of land, which is actually water tiles
    for (std::uint32_t y = 15; y < 25; ++y)
    {
      map.tiles[y * kMapSize + 10].terrain_sprite = 7;
      map.tiles[y * kMapSize + 10].mirroring = 1;
      map.tiles[y * kMapSize + 11].terrain_sprite = 7;
      map.tiles[y * kMapSize + 11].mirroring = 0;
    }

    // Fake diagonal line of land.
    map.tiles[20 * kMapSize + 20].terrain_sprite = 17;
    map.tiles[20 * kMapSize + 20].mirroring = 3;
    map.tiles[20 * kMapSize + 21].terrain_sprite = 17;
    map.tiles[20 * kMapSize + 21].mirroring = 0;
    map.tiles[20 * kMapSize + 22].terrain_sprite = 15;
    map.tiles[20 * kMapSize + 22].mirroring = 3;
    map.tiles[19 * kMapSize + 20].terrain_sprite = 19;
    map.tiles[19 * kMapSize + 20].mirroring = 0;
    map.tiles[19 * kMapSize + 21].terrain_sprite = 17;
    map.tiles[19 * kMapSize + 21].mirroring = 3;
    map.tiles[19 * kMapSize + 22].terrain_sprite = 17;
    map.tiles[19 * kMapSize + 22].mirroring = 0;
  }
}

int main(int argc, char** argv)
{
  if (argc != 2) {
    std::cout << "Usage: h3mparser map-path" << std::endl;
    return -1;
  }

  try
  {
    const fs::path path_map(argv[1]);
    std::ifstream stream(path_map, std::ios_base::in | std::ios_base::binary);
    const h3m::Map map = h3m::parseh3m(stream);
    stream.close();
    h3m::writeText(std::cout, map);
    std::ofstream out_stream("no_objects_or_events.h3m", std::ios_base::out | std::ios_base::binary);
    h3m::writeh3m(out_stream, map);

    {
      const fs::path test_map_path("test_map.h3m");
      std::ofstream out_stream(test_map_path, std::ios_base::out | std::ios_base::binary);
      h3m::Map test_map = generateTestMap();
      fillWithWaterTiles(test_map);
      drawFakeIslands(test_map);
      std::cout << "Generated a test map." << std::endl;
      h3m::writeh3m(out_stream, test_map);
      std::cout << "Wrote the generated map to test_map.h3m." << std::endl;
    }
  }
  catch (const std::exception& error)
  {
    std::cerr << error.what() << std::endl;
  }
  catch (...)
  {
    std::cerr << "Unknown error." << std::endl;
  }

  return 0;
}
